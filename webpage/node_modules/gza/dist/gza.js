(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process){
/* globals CustomEvent */
process.distjs = true
let loadjs = require('distjs').loadjs

const build = name => {
  // Fast Load for Chrome (avoids skip before render)
  const getChromeVersion = (force) => {
    if (force) return true
    var raw = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)
    return raw ? parseInt(raw[2], 10) > 59 : false
  }
  if (getChromeVersion()) require('./')

  window.addEventListener('WebComponentsReady', () => {
    let event = new CustomEvent(`${name}-ready`, require('./'))
    window.dispatchEvent(event)
  })
  const polyfill = 'https://cdnjs.cloudflare.com/ajax/libs/webcomponentsjs/1.0.12/webcomponents-loader.js'
  loadjs([{async: true, url: polyfill}])
}

build(require('./package.json').name)

}).call(this,require('_process'))
},{"./":2,"./package.json":10,"_process":6,"distjs":4}],2:[function(require,module,exports){
(function (process){
/* globals HTMLElement */
const RZA = require('rza')
const raekwon = require('raekwon')
const parse = require('./lib/parser')

const render = async (el, arr, settings, innerHTML) => {
  let tmp = arr.map(t => {
    if (typeof t === 'string') return t
    else if (typeof t === 'function') return t(settings, innerHTML)
    /* For some reason istanbul can't just ignore the else statement here. */
    else /* istanbul ignore next */ if (t instanceof HTMLElement) {
      return t
    /* Can't test this effectively since renders aren't sync */
    /* istanbul ignore next */
    } else throw new Error(`Unknown type in template: ${t}`)
  })
  let results = await Promise.all(tmp)
  return raekwon(el, results)
}

const nowhitespace = str => {
  return str.replace(/\n/g, '').replace(/ /g, '')
}

const gza = (strings, ...keys) => {
  let parsed = parse(strings, keys)

  class CustomElement extends RZA {
    async render (settings, innerHTML) {
      if (!this._constructed) {
        this._constructed = true
        for (const c of parsed.constructors) {
          await c(this)
        }
        /* We have don't want constructors to trigger another render.
           Instead, we can just reset the re-render and settings state.
         */
        this._rerender = false
        /* Since we are suppressing re-render we need to re-pull settings
           because they can be altered by the init function.
        */
        settings = Object.assign({}, this._settings)
      }
      let _render = this.renderElement
      if (parsed.shadow.filter(s => typeof s === 'function').length) {
        await render(this.shadowRoot, parsed.shadow, settings, innerHTML)
      }
      await render(_render, parsed.template, settings, innerHTML)

      return _render
    }

    get defaults () {
      return parsed.defaults
    }
    get shadow () {
      if (parsed.shadow.filter(s => typeof s === 'function').length) {
        /* placeholder shadow until the real one shows up */
        return '<style>:host {margin: 0 0 0 0; padding: 0 0 0 0;}</style>'
      } else if (nowhitespace(parsed.shadow.join('')).length > 1) {
        return parsed.shadow.join('')
      } else {
        return super.shadow
      }
    }
  }

  let className = parsed.tagName.split('-').map(
    s => s[0].toUpperCase() + s.slice(1)
  ).join('')

  Object.defineProperty(CustomElement, 'name', {value: className})

  window.customElements.define(parsed.tagName, CustomElement)

  return CustomElement
}

module.exports = gza

/* Expose global in standalone bundle. */
/* istanbul ignore if */
if (process.distjs) {
  /* istanbul ignore next */
  window.gza = gza
}

}).call(this,require('_process'))
},{"./lib/parser":3,"_process":6,"raekwon":7,"rza":8}],3:[function(require,module,exports){
const flat = string => string.replace(/ /g, '')

const findClose = (str, tagName) => {
  let i = str.indexOf('<')
  while (i !== -1) {
    let tag = flat(str.slice(i, str.indexOf('>', i)))
    if (tag === `</${tagName}`) return i
    i = str.indexOf('<', i + 1)
  }
  throw new Error(`Cannot find close position for tagName: ${tagName}`)
}

const parser = (strings, keys) => {
  let str = strings.join('')
  let elementOpen = str.indexOf('<')
  let elementClose = str.indexOf('>')
  let tagName = flat(str.slice(elementOpen + 1, elementClose))
  let templateOpen = elementClose + 1
  let templateClose = findClose(str, tagName)
  let shadowOpen = str.indexOf('>', templateClose + 1) + 1

  let defaults = {}
  let constructors = []

  let templateInserts = []
  let shadowInserts = []
  let pos = 0
  for (let i = 0; i < keys.length; i++) {
    pos = (pos + strings[i].length)
    if (pos <= elementOpen) constructors.push(keys[i])
    else if (pos <= elementClose) defaults = keys[i]
    else if (pos <= shadowOpen) templateInserts.push([pos, keys[i]])
    else shadowInserts.push([pos, keys[i]])
  }

  let template = []
  let shadow = []

  let i = templateOpen
  while (templateInserts.length) {
    let [pos, insert] = templateInserts.shift()
    template.push(str.slice(i, pos))
    template.push(insert)
    i = pos
  }
  template.push(str.slice(i, templateClose))

  i = shadowOpen
  while (shadowInserts.length) {
    let [pos, insert] = shadowInserts.shift()
    shadow.push(str.slice(i, pos))
    shadow.push(insert)
    i = pos
  }
  shadow.push(str.slice(i))

  return {
    constructors,
    tagName,
    defaults,
    template,
    shadow
  }
}

module.exports = parser

},{}],4:[function(require,module,exports){
exports.loadjs = require('load-js')

},{"load-js":5}],5:[function(require,module,exports){
(function(global, factory) {
  if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
    // CommonJS support
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    // Do AMD support
    define(["loadJS"], factory);
  } else {
    // Do browser support
    global.loadJS = factory();
  }
})(this, function() {
  var cache = {};
  var head = document.getElementsByTagName("head")[0] || document.documentElement;

  function exec(options) {
    if (typeof options === "string") {
      options = {
        url: options
      };
    }

    var cacheId = options.id || options.url;
    var cacheEntry = cache[cacheId];

    if (cacheEntry) {
      console.log("load-js: cache hit", cacheId);
      return cacheEntry;
    }
    else if (options.allowExternal !== false) {
      var el = getScriptById(options.id) || getScriptByUrl(options.url);

      if (el) {
        var promise = Promise.resolve(el);

        if (cacheId) {
          cache[cacheId] = promise;
        }

        return promise;
      }
    }

    if (!options.url && !options.text) {
      throw new Error("load-js: must provide a url or text to load");
    }

    var pending = (options.url ? loadScript : runScript)(head, createScript(options));

    if (cacheId && options.cache !== false) {
      cache[cacheId] = pending;
    }

    return pending;
  }

  function runScript(head, script) {
    head.appendChild(script);
    return Promise.resolve(script);
  }

  function loadScript(head, script) {
    return new Promise(function(resolve, reject) {
      // Handle Script loading
      var done = false;

      // Attach handlers for all browsers.
      //
      // References:
      // http://stackoverflow.com/questions/4845762/onload-handler-for-script-tag-in-internet-explorer
      // http://stevesouders.com/efws/script-onload.php
      // https://www.html5rocks.com/en/tutorials/speed/script-loading/
      //
      script.onload = script.onreadystatechange = function() {
        if (!done && (!script.readyState || script.readyState === "loaded" || script.readyState === "complete")) {
          done = true;

          // Handle memory leak in IE
          script.onload = script.onreadystatechange = null;
          resolve(script);
        }
      };

      script.onerror = reject;

      head.appendChild(script);
    });
  }

  function createScript(options) {
    var script = document.createElement("script");
    script.charset = options.charset || "utf-8";
    script.type = options.type || "text/javascript";
    script.async = !!options.async;
    script.id = options.id || options.url;
    script.loadJS = "watermark";

    if (options.url) {
      script.src = options.url;
    }

    if (options.text) {
      script.text = options.text;
    }

    return script;
  }

  function getScriptById(id) {
    var script = id && document.getElementById(id);

    if (script && script.loadJS !== "watermark") {
      console.warn("load-js: duplicate script with id:", id);
      return script;
    }
  }

  function getScriptByUrl(url) {
    var script = url && document.querySelector("script[src='" + url + "']");

    if (script && script.loadJS !== "watermark") {
      console.warn("load-js: duplicate script with url:", url);
      return script;
    }
  }

  return function load(items) {
    return items instanceof Array ?
      Promise.all(items.map(exec)) :
      exec(items);
  }
});

},{}],6:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(require,module,exports){
/* globals HTMLElement */
require('setimmediate')
const random = () => Math.random().toString(36).substring(7)

let observed = arr => {
  let handler = {
    set: (...args) => {
      let [, key, value] = args
      if (arr.onchange) arr.onchange(...args)
      if (Array.isArray(value)) {
        value = observed(value)
      }
      arr[key] = value
      return true
    }
  }
  for (let i = 0; i < arr.length; i++) {
    let value = arr[i]
    if (Array.isArray(value)) {
      arr[i] = observed(value)
    }
  }
  return new Proxy(arr, handler)
}

let flat = function * (arr) {
  for (let i = 0; i < arr.length; i++) {
    let value = arr[i]
    if (Array.isArray(value)) yield * flat(value)
    else yield value
  }
}

let allarrays = function * (arr) {
  for (let i = 0; i < arr.length; i++) {
    let value = arr[i]
    if (Array.isArray(value)) {
      yield value
      yield * allarrays(value)
    }
  }
}

let raekwon = (host, arr) => {
  let ret = observed(arr)

  let promise = new Promise(resolve => {
    let sync = (...args) => {
      if (host.__timeout) clearImmediate(host.__timeout)
      host.__timeout = setImmediate(() => {
        let replacements = {}

        let mapv = function * (arr) {
          for (let r of flat(arr)) {
            /* istanbul ignore else */
            if (typeof r === 'string') yield r
            else if (typeof r === 'undefined') yield ''
            else if (typeof r === 'number') yield r.toString()
            else if (typeof r === 'boolean') yield r.toString()
            else if (r === null) yield ''
            else if (r instanceof HTMLElement) {
              let id = random()
              replacements[id] = r
              yield `<span raekwon="${id}"></span>`
            } else {
              throw new Error(`Unknown type in template return: ${typeof r}.`)
            }
          }
        }
        host.innerHTML = Array.from(mapv(ret)).join('')
        for (let id in replacements) {
          let span = host.querySelector(`span[raekwon="${id}"`)
          let rep = replacements[id]
          if (rep.parentNode) rep.parentNode.removeChild(rep)
          span.parentNode.replaceChild(rep, span)
        }
        resolve(ret)
      })
    }

    sync()

    for (let r of allarrays(ret)) {
      r.onchange = sync
    }
    ret.onchange = sync
  })
  return promise
}

module.exports = raekwon
module.exports.flat = flat
module.exports.observed = observed
module.exports.allarrays = allarrays

},{"setimmediate":9}],8:[function(require,module,exports){
/* globals MutationObserver, HTMLElement */
require('setimmediate')
const {observed} = require('raekwon')

const values = o => Object.keys(o).map(k => o[k])

const observer = (element, onAttributes) => {
  var observer = new MutationObserver(mutations => {
    let valid = m => {
      if (m.target !== element) return false
      if (!element._render || element._rendering) return false
      return true
    }

    mutations = Array.from(mutations).filter(valid)
    if (!mutations.length) return

    let attrs = mutations.filter(m => m.type === 'attributes')
    if (attrs.length) {
      onAttributes(Object.assign({},
        ...attrs
        .filter(m => m.type === 'attributes')
        .map(m => m.attributeName)
        .map(attr => {
          let o = {}

          o[attr] = element.getAttribute(attr)
          return o
        })
      ))
    }

    mutations.filter(m => m.type === 'childList').forEach(m => {
      let nodes = Array.from(m.addedNodes).concat(Array.from(m.removedNodes))
      nodes = nodes.filter(n => {
        /* look at the parent of textNodes */
        if (!n.tagName) n = n.parentNode
        /* ignore anything in the render slot */
        return n.getAttribute('slot') !== 'render'
      })
      if (!nodes.length) return
      element._render()
    })
  })

  observer.observe(element, {
    attributes: true,
    childList: true,
    subtree: true,
    characterData: true
  })
  return observer
}

class RZA extends HTMLElement {
  waitFor (key) {
    return new Promise((resolve, reject) => {
      if (!this._waits[key]) this._waits[key] = []
      this._waits[key].push([resolve, reject])
    })
  }
  constructor () {
    super()
    this._afterRender = []
    this._waits = {}

    setImmediate(async () => {
      let _keys
      let _defaults = {}
      /* istanbul ignore else */
      if (Array.isArray(this.defaults)) {
        _keys = this.defaults
        _defaults = {}
      } else if (typeof this.defaults === 'object') {
        _keys = Object.keys(this.defaults)
        _defaults = this.defaults
      } else if (!this.defaults) {
        _keys = []
      } else {
        throw new Error(`Unknown object set for defaults: ${typeof this.defaults}`)
      }

      this._settings = Object.assign({}, _defaults)

      let _initSettings = {}
      let _defaultPromises = {}

      let bindKey = key => {
        if (this[key]) {
          _initSettings[key] = this[key]
        } else if (!this.hasAttribute(key)) {
          /* This is going to run initial render with
             the default setting.
          */
          if (typeof this._settings[key] === 'function') {
            this._settings[key] = this._settings[key]()
            _defaultPromises[key] = this._settings[key]
          }
        }
        Object.defineProperty(this, key, {
          get: () => this._settings[key],
          set: value => {
            if (Array.isArray(value)) {
              value = observed(value)
            }
            if (typeof _defaults[key] === 'boolean') {
              if (value === 'true') value = true
              if (value === 'false') value = false
            }
            this._settings[key] = value
            if (this._waits[key]) {
              while (this._waits[key].length) {
                let [resolve] = this._waits[key].shift()
                resolve(value)
              }
            }
            this._render()
          }
        })

        if (typeof _defaults[key] === 'boolean' &&
            this.hasAttribute(key) &&
            typeof this.getAttribute(key) === 'undefined'
            ) {
          this[key] = !_defaults[key]
        } else {
          if (this.hasAttribute(key)) {
            this[key] = this.getAttribute(key)
          }
        }
      }

      _keys.forEach(bindKey)

      for (let key in _initSettings) {
        this[key] = _initSettings[key]
      }

      observer(this, attributes => {
        for (let key in attributes) {
          if (_keys.includes(key)) {
            this[key] = attributes[key]
          }
        }
      })
      await Promise.all(values(_defaultPromises))
      for (let key in _defaultPromises) {
        this[key] = await _defaultPromises[key]
      }

      let waitFor = key => {
        if (!_keys.includes(key)) {
          this.addSetting(key, this[key])
        }
        if (typeof this[key] !== 'undefined') {
          return Promise.resolve(this[key])
        }
        return new Promise((resolve, reject) => {
          if (!this._waits[key]) this._waits[key] = []
          this._waits[key].push([resolve, reject])
        })
      }

      this.addSetting = (key, value) => {
        if (!_keys.includes(key)) {
          bindKey(key)
          _keys.push(key)
        }
        if (typeof value !== 'undefined') {
          this[key] = value
        }
      }
      this.waitFor = waitFor
      this._settings.waitFor = waitFor

      this._render()
    })

    /* Setup ShadowDOM Immediately so that display of
       existing innerHTML is not shown.
    */
    let shadowRoot = this.attachShadow({mode: 'open'})
    shadowRoot.innerHTML = this.shadow
  }

  /* Fix casing of attribute set/get */
  setAttribute (key, value) {
    this.setAttributeNS(null, key, value)
  }
  getAttribute (key) {
    for (let atr of this.attributes) {
      if (atr.nodeName === key) return atr.nodeValue
    }
    return undefined
  }

  set shadow (value) {
    this.shadowRoot.innerHTML = value
  }

  nextRender () {
    return new Promise((resolve, reject) => {
      this._afterRender.push([resolve, reject])
    })
  }

  /* Internal batch renderer */
  async _render () {
    /* timeout is to defer rendering
       until after multiple attributes get
       set in a single tick.

       rerender is to force another render if
       the settings change while rendering is
       taking place.
    */
    //
    if (this._rendering) {
      this._rerender = true
      return
    }
    if (this._timeout) return
    this._timeout = setImmediate(async () => {
      this._timeout = null
      this._rendering = true

      if (!this.renderElement) {
        this.renderElement = document.createElement('render')
        this.renderElement.setAttribute('slot', 'render')
        this.appendChild(this.renderElement)
      }
      if (this.contains(this.renderElement)) {
        this.removeChild(this.renderElement)
      }
      let html = this.innerHTML
      this.appendChild(this.renderElement)
      let settings = Object.assign({}, this._settings)
      let value = await this.render(settings, html)

      if (this._rerender) {
        this._rerender = false
        this._rendering = false
        return this._render()
      }

      if (this.renderElement === value) {
        /* noop, user is directly manipulating the render element */
      } else if (value instanceof HTMLElement) {
        value.setAttribute('slot', 'render')
        this.renderElement.parentNode.removeChild(this.renderElement)
        this.appendChild(value)
        this.renderElement = value
      } else if (typeof value === 'string') {
        this.renderElement.innerHTML = value
      } else if (!value) {
        this.renderElement.innerHTML = ''
      } else {
        // noop
      }
      this._rendering = false

      while (this._afterRender.length) {
        this._afterRender.shift()[0](this.renderElement)
      }
    }, 0)
  }
  get shadow () {
    return `
    <style>
    :host {
      margin: 0 0 0 0;
      padding: 0 0 0 0;
    }
    ::slotted([slot="render"]) {
      margin: 0 0 0 0;
      padding: 0 0 0 0;
    }
    </style>
    <slot name="render"></slot>
    `
  }
}

module.exports = RZA

},{"raekwon":7,"setimmediate":9}],9:[function(require,module,exports){
(function (process,global){
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6â€“8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":6}],10:[function(require,module,exports){
module.exports={
  "name": "gza",
  "version": "1.9.1",
  "description": "Declarative custom HTML elements",
  "main": "index.js",
  "keywords": [],
  "author": "Mikeal Rogers <mikeal.rogers@gmail.com> (http://www.mikealrogers.com)",
  "license": "Apache-2.0",
  "dependencies": {
    "raekwon": "^2.0.0",
    "rza": "^2.7.0"
  },
  "scripts": {
    "commit": "git-cz",
    "test": "tap tests/test-*.js --100",
    "posttest": "standard",
    "precommit": "npm test",
    "prepush": "npm test",
    "commitmsg": "validate-commit-msg",
    "travis-deploy-once": "travis-deploy-once",
    "semantic-release": "semantic-release",
    "prepublishOnly": "distjs"
  },
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  },
  "devDependencies": {
    "browserify": "^16.1.0",
    "budo": "^11.1.3",
    "cappadonna": "^1.3.0",
    "codecov": "^3.0.0",
    "cz-conventional-changelog": "^2.1.0",
    "distjs": "^1.1.0",
    "husky": "^0.14.3",
    "travis-deploy-once": "4.3.4",
    "semantic-release": "12.4.1",
    "standard": "^10.0.3",
    "tap": "^10.7.2",
    "validate-commit-msg": "^2.14.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mikeal/gza.git"
  },
  "standard": {
    "ignore": [
      "dist"
    ]
  }
}

},{}]},{},[1]);
